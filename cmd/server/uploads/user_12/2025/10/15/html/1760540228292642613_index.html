<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoCdk Pro Trading Bot</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #7c3aed;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #0f172a;
            --dark-light: #1e293b;
            --dark-lighter: #334155;
            --text: #f8fafc;
            --text-light: #cbd5e1;
            --border: #475569;
        }

        body {
            background: var(--dark);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 12px;
            font-weight: bold;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1.2;
        }

        .tagline {
            color: var(--text-light);
            font-size: 14px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: var(--dark-light);
            border-radius: 20px;
            font-size: 14px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: var(--warning);
        }

        .status-dot.disconnected {
            background: var(--danger);
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .chart-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .market-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--dark-light);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .symbol-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .symbol {
            font-size: 18px;
            font-weight: bold;
            color: var(--text);
        }

        .price-info {
            display: flex;
            gap: 20px;
        }

        .price-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .price-label {
            font-size: 12px;
            color: var(--text-light);
        }

        .price-value {
            font-size: 18px;
            font-weight: bold;
        }

        .positive {
            color: var(--success);
        }

        .negative {
            color: var(--danger);
        }

        .chart-container {
            background: var(--dark-light);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .chart-title {
            font-size: 18px;
            color: var(--text-light);
        }

        .timeframe-selector {
            display: flex;
            gap: 5px;
            background: var(--dark);
            padding: 5px;
            border-radius: 8px;
        }

        .timeframe-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: transparent;
            border: none;
            color: var(--text-light);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeframe-btn.active {
            background: var(--primary);
            color: white;
        }

        #mainChartCanvas,
        #indicatorChartCanvas {
            width: 100%;
            background: var(--dark);
            border-radius: 8px;
            cursor: crosshair;
        }

        #mainChartCanvas {
            height: 450px;
        }

        #indicatorChartCanvas {
            height: 200px;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .chart-buttons {
            display: flex;
            gap: 10px;
        }

        .chart-type-selector {
            display: flex;
            gap: 5px;
            background: var(--dark);
            padding: 5px;
            border-radius: 8px;
        }

        .chart-type-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: transparent;
            border: none;
            color: var(--text-light);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chart-type-btn.active {
            background: var(--primary);
            color: white;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: var(--dark-light);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .panel-title {
            font-size: 16px;
            color: var(--text-light);
        }

        .color-settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .color-setting {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .color-label {
            font-size: 14px;
            color: var(--text-light);
        }

        .color-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }

        .color-preview {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-success {
            background: var(--success);
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-warning {
            background: var(--warning);
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .indicators-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .indicator-box {
            background: var(--dark);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--primary);
        }

        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .indicator-title {
            font-size: 14px;
            color: var(--text-light);
        }

        .indicator-controls {
            display: flex;
            gap: 8px;
        }

        .indicator-btn {
            padding: 6px 10px;
            font-size: 12px;
        }

        .indicator-settings {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .indicator-setting {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .indicator-setting label {
            font-size: 12px;
            color: var(--text-light);
        }

        .indicator-setting input,
        .indicator-setting select {
            background: var(--dark-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            font-size: 12px;
        }

        textarea {
            width: 100%;
            height: 120px;
            background: var(--dark-light);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            font-size: 13px;
        }

        .tooltip {
            position: absolute;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 100;
            max-width: 200px;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--dark-light);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--dark-lighter);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .market-info {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .price-info {
                width: 100%;
                justify-content: space-between;
            }

            .chart-controls {
                flex-direction: column;
                gap: 10px;
            }

            .chart-buttons {
                justify-content: center;
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th,
        td {
            padding: 8px;
            border: 1px solid var(--border);
            text-align: center;
            font-size: 12px;
        }

        th {
            background: var(--dark-lighter);
        }

        #tradeLogs {
            height: 150px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="logo-container">
                <div class="logo">AC</div>
                <div class="logo-text">
                    <h1>AlgoCdk Pro Trading Bot</h1>
                    <div class="tagline">Advanced charting and algo trading with cloud indicators</div>
                </div>
            </div>
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting to Deriv...</span>
            </div>
        </div>

        <div class="dashboard">
            <div class="chart-section">
                <div class="market-info">
                    <div class="symbol-selector">
                        <div class="symbol" id="currentSymbol">Volatility 10 Index</div>
                        <div class="price-change positive" id="priceChange">+0.25%</div>
                    </div>
                    <div class="price-info">
                        <div class="price-item">
                            <div class="price-label">OPEN</div>
                            <div class="price-value" id="openPrice">1.08542</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">HIGH</div>
                            <div class="price-value positive" id="highPrice">1.08712</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">LOW</div>
                            <div class="price-value negative" id="lowPrice">1.08435</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">CURRENT</div>
                            <div class="price-value" id="currentPrice">1.08672</div>
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Price Chart with Clouds</div>
                        <div class="timeframe-selector">
                            <button class="timeframe-btn active">1m</button>
                            <button class="timeframe-btn">5m</button>
                            <button class="timeframe-btn">15m</button>
                            <button class="timeframe-btn">1h</button>
                            <button class="timeframe-btn">4h</button>
                            <button class="timeframe-btn">1d</button>
                        </div>
                    </div>
                    <canvas id="mainChartCanvas"></canvas>
                    <div class="chart-controls">
                        <div class="chart-type-selector">
                            <button class="chart-type-btn active">Candles</button>
                            <button class="chart-type-btn">Line</button>
                            <button class="chart-type-btn">Area</button>
                        </div>
                        <div class="chart-buttons">
                            <button class="zoom-btn" id="zoomIn"><i class="fas fa-search-plus"></i></button>
                            <button class="zoom-btn" id="zoomOut"><i class="fas fa-search-minus"></i></button>
                            <button class="zoom-btn" id="resetZoom"><i class="fas fa-expand"></i></button>
                        </div>
                    </div>
                    <div class="legend" id="mainChartLegend"></div>
                </div>

                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Signals & Indicators</div>
                        <div id="indicatorValue">Cloud Signal: Waiting...</div>
                    </div>
                    <canvas id="indicatorChartCanvas"></canvas>
                    <div class="legend" id="indicatorChartLegend"></div>
                </div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">Market Settings</div>
                    </div>
                    <div class="symbol-selection">
                        <div class="indicator-setting">
                            <label for="marketSelect">Market:</label>
                            <select id="marketSelect">
                                <option value="forex">Forex</option>
                                <option value="indices" selected>Indices</option>
                                <option value="commodities">Commodities</option>
                                <option value="cryptocurrency">Cryptocurrency</option>
                            </select>
                        </div>
                        <div class="indicator-setting">
                            <label for="symbolSelect">Symbol:</label>
                            <select id="symbolSelect">
                                <option value="R_10">Volatility 10 Index</option>
                                <option value="R_25">Volatility 25 Index</option>
                                <option value="R_50">Volatility 50 Index</option>
                                <option value="R_75">Volatility 75 Index</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">Chart Appearance</div>
                    </div>
                    <div class="color-settings">
                        <div class="color-setting">
                            <div class="color-label">Up Candle:</div>
                            <div class="color-input">
                                <input type="color" id="upColor" value="#22c55e">
                                <div class="color-preview" id="upColorPreview" style="background-color: #22c55e"></div>
                            </div>
                        </div>
                        <div class="color-setting">
                            <div class="color-label">Down Candle:</div>
                            <div class="color-input">
                                <input type="color" id="downColor" value="#ef4444">
                                <div class="color-preview" id="downColorPreview" style="background-color: #ef4444">
                                </div>
                            </div>
                        </div>
                        <div class="color-setting">
                            <div class="color-label">Background:</div>
                            <div class="color-input">
                                <input type="color" id="bgColor" value="#0f172a">
                                <div class="color-preview" id="bgColorPreview" style="background-color: #0f172a"></div>
                            </div>
                        </div>
                        <div class="color-setting">
                            <div class="color-label">Grid Color:</div>
                            <div class="color-input">
                                <input type="color" id="gridColor" value="#334155">
                                <div class="color-preview" id="gridColorPreview" style="background-color: #334155">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">Cloud Indicators</div>
                        <button id="addIndicator" class="indicator-btn btn-success"><i class="fas fa-plus"></i> Add
                            Cloud</button>
                    </div>
                    <div class="controls">
                        <button id="resetCharts" class="btn-warning"><i class="fas fa-redo"></i> Reset</button>
                        <button id="exportChart" class="btn-success"><i class="fas fa-download"></i> Export</button>
                    </div>
                    <div class="indicators-container" id="indicators">
                        <!-- Indicators will be added here dynamically -->
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">Trading Bot Settings</div>
                    </div>
                    <div class="bot-settings">
                        <div class="indicator-setting">
                            <label for="apiToken">API Token:</label>
                            <input type="text" id="apiToken" placeholder="Enter Deriv API Token">
                        </div>
                        <div class="indicator-setting">
                            <label for="stake">Stake ($):</label>
                            <input type="number" id="stake" value="1" min="0.35" step="0.01">
                        </div>
                        <div class="indicator-setting">
                            <label for="duration">Duration (ticks):</label>
                            <input type="number" id="duration" value="5" min="5">
                        </div>
                        <div class="indicator-setting">
                            <label for="tp">Take Profit ($):</label>
                            <input type="number" id="tp" value="0" min="0" step="0.01">
                        </div>
                        <div class="indicator-setting">
                            <label for="sl">Stop Loss ($):</label>
                            <input type="number" id="sl" value="0" min="0" step="0.01">
                        </div>
                        <div class="indicator-setting">
                            <label for="martingale">Martingale Multiplier:</label>
                            <input type="number" id="martingale" value="2" min="0" step="0.1">
                        </div>
                        <div class="controls">
                            <button id="startBot" class="btn-success"><i class="fas fa-play"></i> Start Bot</button>
                            <button id="stopBot" class="btn-danger"><i class="fas fa-stop"></i> Stop Bot</button>
                        </div>
                    </div>
                    <div class="panel-header">
                        <div class="panel-title">Trade Logs</div>
                    </div>
                    <textarea id="tradeLogs" readonly></textarea>
                    <div class="panel-header">
                        <div class="panel-title">Trade History</div>
                    </div>
                    <table id="tradeHistory">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Symbol</th>
                                <th>Type</th>
                                <th>Stake</th>
                                <th>Result</th>
                                <th>Profit</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Chart data and configuration
        let chartData = [];
        let currentTimeframe = '1m';
        let chartType = 'candles';
        let upColor = '#22c55e';
        let downColor = '#ef4444';
        let bgColor = '#0f172a';
        let gridColor = '#334155';
        let activeIndicators = [];

        // Chart interaction state
        let isDragging = false;
        let dragStartX = 0;
        let visibleStartIndex = 0;
        let visibleDataPoints = 50;
        let candleWidth = 10;
        let hoverIndex = null;

        // Canvas elements and contexts
        let mainCanvas, indicatorCanvas;
        let mainCtx, indicatorCtx;

        // Deriv connection state
        let derivConnection = null;
        let isConnected = false;
        let currentSymbol = 'R_10';
        let activeSubscription = null;

        // Bot settings
        let botRunning = false;
        let apiToken = '';
        let authorized = false;
        let baseStake = 1;
        let currentStake = 1;
        let durationTicks = 5;
        let takeProfit = 0;
        let stopLoss = 0;
        let multiplier = 2;
        let lossStreak = 0;
        let prevSignal = 0;
        let activeContract = null;
        let tradeHistory = [];
        let logs = '';
        let pendingProposalId = null;
        let contractSubscriptionId = null;

        // Initialize the application
        function init() {
            initializeCanvases();
            setupEventListeners();
            setupDerivConnection();
            updateUI();
            setupBotEventListeners();
        }

        // Initialize canvas elements
        function initializeCanvases() {
            mainCanvas = document.getElementById('mainChartCanvas');
            indicatorCanvas = document.getElementById('indicatorChartCanvas');

            mainCtx = mainCanvas.getContext('2d');
            indicatorCtx = indicatorCanvas.getContext('2d');

            updateCanvasSizes();
        }

        // Update canvas sizes based on container
        function updateCanvasSizes() {
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;

            indicatorCanvas.width = indicatorCanvas.offsetWidth;
            indicatorCanvas.height = indicatorCanvas.offsetHeight;
        }

        // Ensure array has correct length
        function ensureArrayLength(arr, targetLength) {
            let result = Array.isArray(arr) ? [...arr] : [];
            while (result.length < targetLength) {
                result.push(null);
            }
            result.length = targetLength;
            return result;
        }

        // Recalculate all active indicators
        function recalculateIndicators() {
            activeIndicators.forEach(indicator => {
                const baseId = indicator.id.split('_')[0];
                const indicatorBox = document.querySelector(`[data-indicator-id="${baseId}"]`);
                if (!indicatorBox) {
                    activeIndicators = activeIndicators.filter(ind => ind.id !== indicator.id);
                    return;
                }

                const textarea = indicatorBox.querySelector('textarea');
                if (!textarea || !textarea.value.trim()) return;

                try {
                    const safeData = chartData.map(d => ({
                        close: d.close, open: d.open, high: d.high, low: d.low, time: d.time
                    }));

                    const func = new Function('data', `
                        try {
                            ${textarea.value}
                            const result = typeof calculateIndicator === 'function' ? calculateIndicator(data) : { signals: [], upper: [], lower: [] };
                            
                            if (!result || typeof result !== 'object') {
                                throw new Error('Indicator must return an object');
                            }
                            
                            const output = {
                                signals: ensureArrayLength(result.signals || result.values || [], data.length),
                                upper: ensureArrayLength(result.upper || [], data.length),
                                lower: ensureArrayLength(result.lower || [], data.length)
                            };
                            
                            return output;
                        } catch (e) {
                            throw new Error('Calculation error: ' + e.message);
                        }
                    `);

                    const result = func(safeData);

                    // Update indicator values
                    indicator.values = result.signals;

                    // Update cloud boundaries if they exist
                    const upperIndicator = activeIndicators.find(ind =>
                        ind.type === 'cloud_upper' && ind.id.startsWith(baseId)
                    );
                    const lowerIndicator = activeIndicators.find(ind =>
                        ind.type === 'cloud_lower' && ind.id.startsWith(baseId)
                    );

                    if (upperIndicator) upperIndicator.values = result.upper;
                    if (lowerIndicator) lowerIndicator.values = result.lower;

                } catch (error) {
                    console.error(`Error recalculating indicator ${indicator.name}:`, error);
                    indicator.values = new Array(chartData.length).fill(null);
                }
            });
            drawCharts();
        }

        // Set up Deriv WebSocket connection
        function setupDerivConnection() {
            updateConnectionStatus('connecting', 'Connecting to Deriv...');

            const appId = '1050'; // Demo app ID, replace with your own if needed
            derivConnection = new WebSocket(`wss://ws.binaryws.com/websockets/v3?app_id=${appId}`);

            derivConnection.onopen = () => {
                updateConnectionStatus('connected', 'Connected to Deriv');
                isConnected = true;
                if (apiToken) {
                    derivConnection.send(JSON.stringify({ authorize: apiToken }));
                }
                subscribeToSymbol(currentSymbol);
            };

            derivConnection.onclose = () => {
                updateConnectionStatus('disconnected', 'Disconnected from Deriv');
                isConnected = false;
                authorized = false;
            };

            derivConnection.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus('disconnected', 'Connection error');
            };

            derivConnection.onmessage = (msg) => {
                const data = JSON.parse(msg.data);
                if (data.error) {
                    console.error('Deriv API error:', data.error);
                    log(`API Error: ${data.error.message}`);
                    return;
                }

                if (data.msg_type === 'authorize') {
                    if (data.authorize) {
                        authorized = true;
                        updateConnectionStatus('connected', 'Authorized');
                        log('Authorization successful');
                    } else {
                        authorized = false;
                        updateConnectionStatus('disconnected', 'Authorization failed');
                        log('Authorization failed');
                    }
                } else if (data.msg_type === 'candles') {
                    chartData = data.candles.map(c => ({
                        time: c.epoch,
                        open: parseFloat(c.open),
                        high: parseFloat(c.high),
                        low: parseFloat(c.low),
                        close: parseFloat(c.close),
                        volume: 0
                    }));
                    visibleStartIndex = Math.max(0, chartData.length - visibleDataPoints);
                    recalculateIndicators();
                    updatePriceInfo();
                    activeSubscription = data.subscription?.id;
                    checkForTradeSignal();
                } else if (data.msg_type === 'ohlc') {
                    const ohlc = data.ohlc;
                    const newCandle = {
                        time: parseInt(ohlc.epoch),
                        open: parseFloat(ohlc.open),
                        high: parseFloat(ohlc.high),
                        low: parseFloat(ohlc.low),
                        close: parseFloat(ohlc.close),
                        volume: 0
                    };

                    if (chartData.length > 0) {
                        const last = chartData[chartData.length - 1];
                        if (newCandle.time === last.time) {
                            last.high = Math.max(last.high, newCandle.high);
                            last.low = Math.min(last.low, newCandle.low);
                            last.close = newCandle.close;
                        } else {
                            chartData.push(newCandle);
                            if (chartData.length > 1000) {
                                chartData.shift();
                                activeIndicators.forEach(ind => {
                                    ind.values = ind.values.slice(1);
                                    if (ind.values.length < chartData.length) {
                                        ind.values = ensureArrayLength(ind.values, chartData.length);
                                    }
                                });
                            }
                        }
                        recalculateIndicators();
                    } else {
                        chartData.push(newCandle);
                        recalculateIndicators();
                    }

                    visibleStartIndex = Math.max(0, chartData.length - visibleDataPoints);
                    drawCharts();
                    updatePriceInfo();
                    checkForTradeSignal();
                } else if (data.msg_type === 'proposal') {
                    const proposal = data.proposal;
                    pendingProposalId = proposal.id;
                    const askPrice = proposal.ask_price;
                    log(`Received proposal ID: ${pendingProposalId}, Ask Price: ${askPrice}`);
                    // Buy the contract
                    derivConnection.send(JSON.stringify({
                        buy: pendingProposalId,
                        price: parseFloat(askPrice)
                    }));
                } else if (data.msg_type === 'buy') {
                    const buy = data.buy;
                    activeContract = buy.contract_id;
                    log(`Bought contract ID: ${activeContract}, Price: ${buy.buy_price}`);
                    // Set TP/SL if specified
                    if (takeProfit > 0 || stopLoss > 0) {
                        const limitOrder = {};
                        if (takeProfit > 0) limitOrder.take_profit = takeProfit;
                        if (stopLoss > 0) limitOrder.stop_loss = stopLoss;
                        derivConnection.send(JSON.stringify({
                            contract_update: 1,
                            contract_id: activeContract,
                            limit_order: limitOrder
                        }));
                    }
                    // Subscribe to contract updates
                    derivConnection.send(JSON.stringify({
                        proposal_open_contract: 1,
                        contract_id: activeContract,
                        subscribe: 1
                    }));
                } else if (data.msg_type === 'contract_update') {
                    log(`Contract update successful for ID: ${data.contract_update.contract_id}`);
                } else if (data.msg_type === 'proposal_open_contract') {
                    const contract = data.proposal_open_contract;
                    if (contractSubscriptionId === null && data.subscription) {
                        contractSubscriptionId = data.subscription.id;
                    }
                    if (contract.status !== 'open') {
                        const profit = contract.profit || (contract.sell_price - contract.buy_price);
                        const result = profit > 0 ? 'Win' : 'Loss';
                        log(`Contract ${contract.contract_id} closed: ${result}, Profit: ${profit}`);
                        addToHistory({
                            time: new Date(contract.sell_time * 1000).toLocaleString(),
                            symbol: contract.underlying_symbol || currentSymbol,
                            type: contract.contract_type === 'CALL' ? 'Rise' : 'Fall',
                            stake: contract.buy_price,
                            result,
                            profit
                        });
                        if (profit < 0 && multiplier > 1) {
                            lossStreak++;
                            currentStake = baseStake * Math.pow(multiplier, lossStreak);
                            log(`Martingale activated: Next stake ${currentStake.toFixed(2)}`);
                        } else {
                            lossStreak = 0;
                            currentStake = baseStake;
                        }
                        activeContract = null;
                        if (contractSubscriptionId) {
                            derivConnection.send(JSON.stringify({ forget: contractSubscriptionId }));
                            contractSubscriptionId = null;
                        }
                    }
                }
            };
        }

        // Function to check for new trade signal
        function checkForTradeSignal() {
            const signalIndicator = activeIndicators.find(ind => ind.type === 'cloud_signals');
            if (signalIndicator) {
                const currentSignal = signalIndicator.values[chartData.length - 1] || 0;
                if (botRunning && currentSignal !== 0 && currentSignal !== prevSignal && !activeContract) {
                    const type = currentSignal === 1 ? 'CALL' : 'PUT';
                    placeTrade(type);
                }
                prevSignal = currentSignal;
            }
        }

        // Function to place a trade
        function placeTrade(contract_type) {
            if (!authorized) {
                log('Cannot place trade: Not authorized');
                return;
            }
            log(`Placing ${contract_type} trade with stake ${currentStake.toFixed(2)}`);
            derivConnection.send(JSON.stringify({
                proposal: 1,
                amount: currentStake,
                basis: "stake",
                contract_type: contract_type,
                currency: "USD",
                duration: durationTicks,
                duration_unit: "t",
                symbol: currentSymbol
            }));
        }

        // Log message
        function log(message) {
            logs += new Date().toLocaleString() + ': ' + message + '\n';
            document.getElementById('tradeLogs').value = logs;
            document.getElementById('tradeLogs').scrollTop = document.getElementById('tradeLogs').scrollHeight;
        }

        // Add to trade history
        function addToHistory(trade) {
            tradeHistory.push(trade);
            const tbody = document.getElementById('tradeHistory').querySelector('tbody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${trade.time}</td>
                <td>${trade.symbol}</td>
                <td>${trade.type}</td>
                <td>${trade.stake.toFixed(2)}</td>
                <td>${trade.result}</td>
                <td class="${trade.profit > 0 ? 'positive' : 'negative'}">${trade.profit.toFixed(2)}</td>
            `;
            tbody.appendChild(row);
        }

        // Update connection status UI
        function updateConnectionStatus(status, message) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            statusDot.className = 'status-dot ' + status;
            statusText.textContent = message;
        }

        // Subscribe to a symbol for real-time data
        function subscribeToSymbol(symbol) {
            if (!isConnected) return;

            if (activeSubscription) {
                try {
                    derivConnection.send(JSON.stringify({ "forget": activeSubscription }));
                } catch (e) {
                    console.warn('Error forgetting subscription:', e);
                }
                activeSubscription = null;
            }

            currentSymbol = symbol;
            updateConnectionStatus('connected', `Connected - ${getSymbolDisplayName(symbol)}`);

            const granularityMap = {
                '1m': 60, '5m': 300, '15m': 900, '1h': 3600, '4h': 14400, '1d': 86400
            };
            const granularity = granularityMap[currentTimeframe] || 60;
            const count = 500;

            const req = {
                "ticks_history": symbol,
                "end": "latest",
                "count": count,
                "style": "candles",
                "granularity": granularity,
                "subscribe": 1
            };

            derivConnection.send(JSON.stringify(req));
        }

        // Get display name for a symbol
        function getSymbolDisplayName(symbol) {
            const symbolMap = {
                'R_10': 'Volatility 10 Index', 'R_25': 'Volatility 25 Index',
                'R_50': 'Volatility 50 Index', 'R_75': 'Volatility 75 Index'
            };
            return symbolMap[symbol] || symbol;
        }

        // Update price information in the UI
        function updatePriceInfo() {
            if (chartData.length === 0) return;

            const current = chartData[chartData.length - 1];
            const open = chartData[0]?.open || current.open;
            const change = ((current.close - open) / open) * 100;

            let high = current.high;
            let low = current.low;
            for (let i = 0; i < chartData.length; i++) {
                high = Math.max(high, chartData[i].high);
                low = Math.min(low, chartData[i].low);
            }

            document.getElementById('currentSymbol').textContent = getSymbolDisplayName(currentSymbol);
            document.getElementById('priceChange').textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
            document.getElementById('priceChange').className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('openPrice').textContent = open.toFixed(5);
            document.getElementById('highPrice').textContent = high.toFixed(5);
            document.getElementById('lowPrice').textContent = low.toFixed(5);
            document.getElementById('currentPrice').textContent = current.close.toFixed(5);
        }

        // Enhanced main chart indicator drawing with cloud support
        function drawMainChartIndicator(indicator, visibleData, minPrice, maxPrice, padding, chartWidth, chartHeight) {
            const height = mainCanvas.height;
            const visibleStart = visibleStartIndex;
            const priceRange = maxPrice - minPrice;

            // Handle cloud visualization
            if (indicator.type === 'cloud_upper' || indicator.type === 'cloud_lower') {
                const baseId = indicator.id.split('_')[0];
                const otherType = indicator.type === 'cloud_upper' ? 'cloud_lower' : 'cloud_upper';
                const otherBoundary = activeIndicators.find(ind =>
                    ind.type === otherType && ind.id.startsWith(baseId)
                );

                if (!otherBoundary || !otherBoundary.values) return;

                const upperValues = indicator.values.slice(visibleStart, visibleStart + visibleData.length);
                const lowerValues = otherBoundary.values.slice(visibleStart, visibleStart + visibleData.length);

                // Determine cloud color
                let isBullish = false;
                for (let i = 0; i < Math.min(upperValues.length, lowerValues.length); i++) {
                    if (upperValues[i] !== null && lowerValues[i] !== null) {
                        isBullish = upperValues[i] > lowerValues[i];
                        break;
                    }
                }

                mainCtx.fillStyle = isBullish ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)';

                mainCtx.beginPath();
                mainCtx.moveTo(padding.left, height - padding.bottom);

                for (let i = 0; i < Math.min(upperValues.length, lowerValues.length); i++) {
                    const x = padding.left + (i / visibleData.length) * chartWidth;
                    const upperVal = upperValues[i];
                    const lowerVal = lowerValues[i];

                    if (upperVal !== null && lowerVal !== null && isFinite(upperVal) && isFinite(lowerVal)) {
                        const upperY = height - padding.bottom - ((Math.max(upperVal, lowerVal) - minPrice) / priceRange) * chartHeight;
                        const lowerY = height - padding.bottom - ((Math.min(upperVal, lowerVal) - minPrice) / priceRange) * chartHeight;

                        if (i === 0) {
                            mainCtx.moveTo(x, upperY);
                            mainCtx.lineTo(x, lowerY);
                        } else {
                            mainCtx.lineTo(x, upperY);
                            mainCtx.lineTo(x, lowerY);
                        }
                    }
                }

                mainCtx.lineTo(padding.left + chartWidth, height - padding.bottom);
                mainCtx.lineTo(padding.left, height - padding.bottom);
                mainCtx.closePath();
                mainCtx.fill();

                // Cloud border
                mainCtx.strokeStyle = isBullish ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)';
                mainCtx.lineWidth = 1;
                mainCtx.stroke();

                return;
            }

            // Handle buy/sell signal markers
            if (indicator.type === 'cloud_signals') {
                const visibleSignals = indicator.values.slice(visibleStart, visibleStart + visibleData.length);

                for (let i = 0; i < visibleSignals.length; i++) {
                    const signal = visibleSignals[i];
                    if (signal === null || !isFinite(signal)) continue;

                    const x = padding.left + (i / visibleData.length) * chartWidth;
                    const bar = visibleData[i];
                    let y = height - padding.bottom - ((bar.low - minPrice) / priceRange) * chartHeight - 15;

                    if (signal === 1) { // Buy
                        mainCtx.fillStyle = '#22c55e';
                        mainCtx.beginPath();
                        mainCtx.moveTo(x, y);
                        mainCtx.lineTo(x - 8, y + 16);
                        mainCtx.lineTo(x + 8, y + 16);
                        mainCtx.closePath();
                        mainCtx.fill();

                        mainCtx.fillStyle = '#ffffff';
                        mainCtx.font = 'bold 10px Arial';
                        mainCtx.textAlign = 'center';
                        mainCtx.fillText('BUY', x, y + 12);

                    } else if (signal === -1) { // Sell
                        mainCtx.fillStyle = '#ef4444';
                        mainCtx.beginPath();
                        mainCtx.moveTo(x, y - 16);
                        mainCtx.lineTo(x - 8, y);
                        mainCtx.lineTo(x + 8, y);
                        mainCtx.closePath();
                        mainCtx.fill();

                        mainCtx.fillStyle = '#ffffff';
                        mainCtx.font = 'bold 10px Arial';
                        mainCtx.textAlign = 'center';
                        mainCtx.fillText('SELL', x, y - 8);
                    }
                }
                return;
            }

            // Original line drawing for other indicators
            const visibleIndicatorValues = indicator.values.slice(visibleStart, visibleStart + visibleData.length);
            const validValues = visibleIndicatorValues.filter(v => v !== null && v !== undefined && isFinite(v));
            if (validValues.length === 0) return;

            mainCtx.strokeStyle = indicator.color;
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash(indicator.pane === 'main' ? [2, 2] : []);
            mainCtx.beginPath();
            let firstPoint = true;

            for (let i = 0; i < visibleIndicatorValues.length; i++) {
                const value = visibleIndicatorValues[i];
                if (value === null || value === undefined || !isFinite(value)) continue;

                const x = padding.left + (i / visibleData.length) * chartWidth;
                const y = height - padding.bottom - ((value - minPrice) / priceRange) * chartHeight;

                if (firstPoint) {
                    mainCtx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    mainCtx.lineTo(x, y);
                }
            }

            mainCtx.stroke();
            mainCtx.setLineDash([]);
        }

        // Draw signal indicator pane
        function drawSignalIndicatorPane(signalIndicators, visibleData, padding, chartWidth, chartHeight, width) {
            const height = indicatorCanvas.height;

            // Zero line
            indicatorCtx.strokeStyle = gridColor;
            indicatorCtx.lineWidth = 1;
            indicatorCtx.beginPath();
            indicatorCtx.moveTo(padding.left, height - padding.bottom);
            indicatorCtx.lineTo(width - padding.right, height - padding.bottom);
            indicatorCtx.stroke();

            // Buy/sell zones
            indicatorCtx.fillStyle = 'rgba(34, 197, 94, 0.1)';
            indicatorCtx.fillRect(padding.left, height - padding.bottom - 20, chartWidth, 20);
            indicatorCtx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            indicatorCtx.fillRect(padding.left, height - padding.bottom + 10, chartWidth, 20);

            // Zone labels
            indicatorCtx.fillStyle = '#22c55e';
            indicatorCtx.font = '12px Arial';
            indicatorCtx.textAlign = 'center';
            indicatorCtx.fillText('BUY ZONE', padding.left + chartWidth / 4, height - padding.bottom - 5);
            indicatorCtx.fillStyle = '#ef4444';
            indicatorCtx.fillText('SELL ZONE', padding.left + chartWidth / 4 * 3, height - padding.bottom + 35);

            // Signal markers
            signalIndicators.forEach(indicator => {
                const visibleSignals = indicator.values.slice(visibleStartIndex, visibleStartIndex + visibleData.length);

                for (let i = 0; i < visibleSignals.length; i++) {
                    const signal = visibleSignals[i];
                    if (signal === null || !isFinite(signal)) continue;

                    const x = padding.left + (i / visibleData.length) * chartWidth;

                    if (signal === 1) {
                        indicatorCtx.fillStyle = '#22c55e';
                        indicatorCtx.beginPath();
                        indicatorCtx.arc(x, height - padding.bottom - 10, 6, 0, Math.PI * 2);
                        indicatorCtx.fill();
                    } else if (signal === -1) {
                        indicatorCtx.fillStyle = '#ef4444';
                        indicatorCtx.beginPath();
                        indicatorCtx.arc(x, height - padding.bottom + 30, 6, 0, Math.PI * 2);
                        indicatorCtx.fill();
                    }
                }
            });
        }

        // Draw all charts
        function drawCharts() {
            drawCandlestickChart();
            drawIndicatorChart();
            updateLegends();
            updateIndicatorValue();
        }

        // Draw candlestick chart (simplified version)
        function drawCandlestickChart() {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const padding = { top: 40, right: 60, bottom: 40, left: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            mainCtx.clearRect(0, 0, width, height);
            mainCtx.fillStyle = bgColor;
            mainCtx.fillRect(0, 0, width, height);

            const visibleData = chartData.slice(
                visibleStartIndex,
                Math.min(visibleStartIndex + visibleDataPoints, chartData.length)
            );

            if (visibleData.length === 0) return;

            let minPrice = Number.MAX_VALUE;
            let maxPrice = Number.MIN_VALUE;

            for (const bar of visibleData) {
                minPrice = Math.min(minPrice, bar.low);
                maxPrice = Math.max(maxPrice, bar.high);
            }

            const pricePadding = (maxPrice - minPrice) * 0.05;
            minPrice -= pricePadding;
            maxPrice += pricePadding;
            const priceRange = maxPrice - minPrice;

            candleWidth = Math.max(5, Math.min(20, chartWidth / visibleData.length * 0.7));

            // Draw grid
            mainCtx.strokeStyle = gridColor;
            mainCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = padding.left + (i / 10) * chartWidth;
                mainCtx.beginPath();
                mainCtx.moveTo(x, padding.top);
                mainCtx.lineTo(x, height - padding.bottom);
                mainCtx.stroke();
            }
            for (let i = 0; i <= 10; i++) {
                const y = padding.top + (i / 10) * chartHeight;
                mainCtx.beginPath();
                mainCtx.moveTo(padding.left, y);
                mainCtx.lineTo(width - padding.right, y);
                mainCtx.stroke();
            }

            // Draw candlesticks
            if (chartType === 'candles') {
                for (let i = 0; i < visibleData.length; i++) {
                    const bar = visibleData[i];
                    const x = padding.left + (i / visibleData.length) * chartWidth;
                    const openY = height - padding.bottom - ((bar.open - minPrice) / priceRange) * chartHeight;
                    const closeY = height - padding.bottom - ((bar.close - minPrice) / priceRange) * chartHeight;
                    const highY = height - padding.bottom - ((bar.high - minPrice) / priceRange) * chartHeight;
                    const lowY = height - padding.bottom - ((bar.low - minPrice) / priceRange) * chartHeight;

                    const isUp = bar.close >= bar.open;
                    mainCtx.strokeStyle = isUp ? upColor : downColor;
                    mainCtx.fillStyle = isUp ? upColor : downColor;

                    // Wick
                    mainCtx.beginPath();
                    mainCtx.moveTo(x, highY);
                    mainCtx.lineTo(x, lowY);
                    mainCtx.stroke();

                    // Body
                    const bodyTop = Math.min(openY, closeY);
                    const bodyHeight = Math.abs(openY - closeY);
                    if (bodyHeight > 0) {
                        mainCtx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    }
                }
            }

            // Draw main pane indicators including clouds
            activeIndicators.filter(ind => ind.pane === 'main').forEach(indicator => {
                drawMainChartIndicator(indicator, visibleData, minPrice, maxPrice, padding, chartWidth, chartHeight);
            });

            // Draw price and time labels
            mainCtx.fillStyle = '#cbd5e1';
            mainCtx.font = '12px Arial';
            mainCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const price = minPrice + (i / 5) * priceRange;
                const y = padding.top + (1 - i / 5) * chartHeight;
                mainCtx.fillText(price.toFixed(5), padding.left - 5, y + 4);
            }

            mainCtx.textAlign = 'center';
            mainCtx.textBaseline = 'top';
            for (let i = 0; i < 5; i++) {
                const dataIndex = Math.floor(i / 4 * (visibleData.length - 1));
                const x = padding.left + (i / 4) * chartWidth;
                const timestamp = visibleData[dataIndex]?.time * 1000;
                if (timestamp) {
                    const date = new Date(timestamp).toLocaleString();
                    mainCtx.fillText(date, x, height - padding.bottom + 10);
                }
            }
        }

        // Enhanced indicator chart with signal support
        function drawIndicatorChart() {
            const width = indicatorCanvas.width;
            const height = indicatorCanvas.height;
            const padding = { top: 20, right: 60, bottom: 30, left: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            indicatorCtx.clearRect(0, 0, width, height);
            indicatorCtx.fillStyle = bgColor;
            indicatorCtx.fillRect(0, 0, width, height);

            const visibleData = chartData.slice(
                visibleStartIndex,
                Math.min(visibleStartIndex + visibleDataPoints, chartData.length)
            );

            if (visibleData.length === 0) return;

            const indicatorPaneIndicators = activeIndicators.filter(ind => ind.pane === 'indicator');
            const signalIndicators = indicatorPaneIndicators.filter(ind => ind.type === 'cloud_signals');

            if (signalIndicators.length > 0) {
                drawSignalIndicatorPane(signalIndicators, visibleData, padding, chartWidth, chartHeight, width);
                return;
            }

            if (indicatorPaneIndicators.length === 0) {
                // Default volatility
                const period = 14;
                const indicatorValues = [];
                for (let i = 0; i < visibleData.length; i++) {
                    const globalIndex = visibleStartIndex + i;
                    if (globalIndex < period - 1) {
                        indicatorValues.push(0);
                        continue;
                    }
                    let sum = 0;
                    for (let j = globalIndex - period + 1; j <= globalIndex; j++) {
                        if (j > 0 && j < chartData.length) {
                            sum += Math.abs(chartData[j].close - chartData[j - 1].close);
                        }
                    }
                    indicatorValues.push(sum / period);
                }

                indicatorCtx.strokeStyle = '#22c55e';
                indicatorCtx.lineWidth = 2;
                indicatorCtx.beginPath();
                for (let i = 0; i < indicatorValues.length; i++) {
                    const x = padding.left + (i / visibleData.length) * chartWidth;
                    const y = height - padding.bottom - (indicatorValues[i] / Math.max(...indicatorValues)) * chartHeight;
                    if (i === 0) {
                        indicatorCtx.moveTo(x, y);
                    } else {
                        indicatorCtx.lineTo(x, y);
                    }
                }
                indicatorCtx.stroke();
            }
        }

        function updateIndicatorValue() {
            const signalIndicators = activeIndicators.filter(ind => ind.type === 'cloud_signals');
            if (signalIndicators.length > 0) {
                const lastSignal = signalIndicators[0].values[signalIndicators[0].values.length - 1];
                const signalText = lastSignal === 1 ? 'BUY' : lastSignal === -1 ? 'SELL' : 'NEUTRAL';
                document.getElementById('indicatorValue').textContent = `Cloud Signal: ${signalText}`;
                document.getElementById('indicatorValue').style.color =
                    lastSignal === 1 ? '#22c55e' : lastSignal === -1 ? '#ef4444' : '#cbd5e1';
            }
        }

        // Update chart legends
        function updateLegends() {
            const mainLegend = document.getElementById('mainChartLegend');
            const indicatorLegend = document.getElementById('indicatorChartLegend');

            mainLegend.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${upColor}"></div>
                    <span>Up</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${downColor}"></div>
                    <span>Down</span>
                </div>
            `;

            indicatorLegend.innerHTML = '';

            activeIndicators.forEach(indicator => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = indicator.color;

                legendItem.appendChild(colorBox);
                legendItem.appendChild(document.createTextNode(indicator.name));

                if (indicator.pane === 'main') {
                    mainLegend.appendChild(legendItem);
                } else {
                    indicatorLegend.appendChild(legendItem);
                }
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            setupColorPickers();
            setupTimeframeButtons();
            setupChartTypeButtons();
            setupSymbolSelection();
            setupChartControls();
            setupIndicatorManagement();
            setupChartInteraction();

            window.addEventListener('resize', () => {
                updateCanvasSizes();
                drawCharts();
            });
        }

        function setupBotEventListeners() {
            document.getElementById('apiToken').addEventListener('change', function () {
                apiToken = this.value;
                if (isConnected) {
                    derivConnection.send(JSON.stringify({ authorize: apiToken }));
                }
            });
            document.getElementById('stake').addEventListener('change', function () {
                baseStake = parseFloat(this.value) || 1;
                currentStake = baseStake;
            });
            document.getElementById('duration').addEventListener('change', function () {
                durationTicks = parseInt(this.value) || 5;
            });
            document.getElementById('tp').addEventListener('change', function () {
                takeProfit = parseFloat(this.value) || 0;
            });
            document.getElementById('sl').addEventListener('change', function () {
                stopLoss = parseFloat(this.value) || 0;
            });
            document.getElementById('martingale').addEventListener('change', function () {
                multiplier = parseFloat(this.value) || 2;
            });
            document.getElementById('startBot').addEventListener('click', function () {
                botRunning = true;
                log('Bot started');
            });
            document.getElementById('stopBot').addEventListener('click', function () {
                botRunning = false;
                log('Bot stopped');
            });
        }

        function setupColorPickers() {
            const upColorInput = document.getElementById('upColor');
            const downColorInput = document.getElementById('downColor');
            const bgColorInput = document.getElementById('bgColor');
            const gridColorInput = document.getElementById('gridColor');

            upColorInput.addEventListener('input', function () {
                upColor = this.value;
                document.getElementById('upColorPreview').style.backgroundColor = upColor;
                drawCharts();
            });

            downColorInput.addEventListener('input', function () {
                downColor = this.value;
                document.getElementById('downColorPreview').style.backgroundColor = downColor;
                drawCharts();
            });

            bgColorInput.addEventListener('input', function () {
                bgColor = this.value;
                document.getElementById('bgColorPreview').style.backgroundColor = bgColor;
                drawCharts();
            });

            gridColorInput.addEventListener('input', function () {
                gridColor = this.value;
                document.getElementById('gridColorPreview').style.backgroundColor = gridColor;
                drawCharts();
            });
        }

        function setupTimeframeButtons() {
            const timeframeBtns = document.querySelectorAll('.timeframe-btn');
            timeframeBtns.forEach(btn => {
                btn.addEventListener('click', function () {
                    timeframeBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTimeframe = this.textContent;
                    subscribeToSymbol(currentSymbol);
                    drawCharts();
                });
            });
        }

        function setupChartTypeButtons() {
            const chartTypeBtns = document.querySelectorAll('.chart-type-btn');
            chartTypeBtns.forEach(btn => {
                btn.addEventListener('click', function () {
                    chartTypeBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    chartType = this.textContent.toLowerCase();
                    drawCharts();
                });
            });
        }

        function setupSymbolSelection() {
            const marketSelect = document.getElementById('marketSelect');
            const symbolSelect = document.getElementById('symbolSelect');

            marketSelect.addEventListener('change', function () {
                updateSymbolOptions(this.value);
            });

            symbolSelect.addEventListener('change', function () {
                subscribeToSymbol(this.value);
            });

            updateSymbolOptions(marketSelect.value);
        }

        function updateSymbolOptions(market) {
            const symbolSelect = document.getElementById('symbolSelect');
            const symbols = {
                forex: [
                    { value: 'frxEURUSD', name: 'EUR/USD' },
                    { value: 'frxGBPUSD', name: 'GBP/USD' }
                ],
                indices: [
                    { value: 'R_10', name: 'Volatility 10 Index' },
                    { value: 'R_25', name: 'Volatility 25 Index' },
                    { value: 'R_50', name: 'Volatility 50 Index' },
                    { value: 'R_75', name: 'Volatility 75 Index' }
                ]
            };

            symbolSelect.innerHTML = (symbols[market] || symbols.indices)
                .map(s => `<option value="${s.value}">${s.name}</option>`).join('');
            subscribeToSymbol(symbolSelect.value);
        }

        function setupChartControls() {
            document.getElementById('zoomIn').addEventListener('click', () => {
                visibleDataPoints = Math.max(10, visibleDataPoints - 10);
                drawCharts();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                visibleDataPoints = Math.min(200, visibleDataPoints + 10);
                drawCharts();
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                visibleDataPoints = 50;
                visibleStartIndex = Math.max(0, chartData.length - visibleDataPoints);
                drawCharts();
            });

            document.getElementById('exportChart').addEventListener('click', () => {
                const dataURL = mainCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'algocdk-cloud-chart.png';
                link.href = dataURL;
                link.click();
            });
        }

        function setupIndicatorManagement() {
            document.getElementById('addIndicator').addEventListener('click', addNewIndicator);
            document.getElementById('resetCharts').addEventListener('click', () => {
                activeIndicators = [];
                document.getElementById('indicators').innerHTML = '';
                drawCharts();
            });
        }

        function addNewIndicator() {
            const indicatorId = Date.now();
            const indicatorBox = document.createElement('div');
            indicatorBox.className = 'indicator-box';
            indicatorBox.setAttribute('data-indicator-id', indicatorId);
            indicatorBox.innerHTML = `
                <div class="indicator-header">
                    <div class="indicator-title">Cloud Buy/Sell Indicator</div>
                    <div class="indicator-controls">
                        <button class="indicator-btn run-btn btn-success"><i class="fas fa-play"></i> Run Cloud</button>
                        <button class="indicator-btn delete-btn btn-danger"><i class="fas fa-trash"></i></button>
                    </div>
                </div>
                <div class="indicator-settings">
                    <div class="indicator-setting">
                        <label>Signal Color:</label>
                        <input type="color" class="indicator-color" value="#3b82f6">
                    </div>
                    <div class="indicator-setting">
                        <label>Display:</label>
                        <select class="indicator-pane">
                            <option value="main">Main Chart (Clouds + Signals)</option>
                            <option value="indicator" selected>Indicator Pane (Signals Only)</option>
                        </select>
                    </div>
                    <div class="indicator-setting">
                        <label>Name:</label>
                        <input type="text" class="indicator-name" value="Cloud Signals" placeholder="Indicator Name">
                    </div>
                </div>
                <textarea>function calculateIndicator(data) {
    const values = new Array(data.length).fill(null);
    const cloudUpper = new Array(data.length).fill(null);
    const cloudLower = new Array(data.length).fill(null);
    
    if (data.length < 26) return { upper: cloudUpper, lower: cloudLower, signals: values };
    
    // Fast and Slow EMAs for cloud boundaries
    const fastPeriod = 9;
    const slowPeriod = 26;
    
    // Calculate fast EMA
    const fastEMA = calculateEMA(data, fastPeriod);
    // Calculate slow EMA  
    const slowEMA = calculateEMA(data, slowPeriod);
    
    // Create cloud boundaries
    for (let i = slowPeriod; i < data.length; i++) {
        const fast = fastEMA[i];
        const slow = slowEMA[i];
        
        if (fast !== null && slow !== null) {
            cloudUpper[i] = Math.max(fast, slow);
            cloudLower[i] = Math.min(fast, slow);
        }
    }
    
    // Generate buy/sell signals
    for (let i = slowPeriod; i < data.length; i++) {
        const price = data[i].close;
        const prevPrice = data[i-1].close;
        const upper = cloudUpper[i];
        const lower = cloudLower[i];
        const prevUpper = cloudUpper[i-1];
        const prevLower = cloudLower[i-1];
        
        if (!upper || !lower) continue;
        
        // Buy: Price breaks above cloud
        if (prevPrice < prevUpper && price > upper) {
            values[i] = 1;
        }
        // Sell: Price breaks below cloud
        else if (prevPrice > prevLower && price < lower) {
            values[i] = -1;
        }
        // Strong buy: Price above bullish cloud
        else if (price > upper && fastEMA[i] > slowEMA[i]) {
            values[i] = 1;
        }
        // Strong sell: Price below bearish cloud
        else if (price < lower && fastEMA[i] < slowEMA[i]) {
            values[i] = -1;
        }
    }
    
    return {
        upper: cloudUpper,
        lower: cloudLower,
        signals: values
    };
}

function calculateEMA(data, period) {
    const values = new Array(data.length).fill(null);
    const multiplier = 2 / (period + 1);
    
    if (data.length < period) return values;
    
    // Initialize with SMA
    let sum = 0;
    for (let i = 0; i < period; i++) {
        sum += data[i].close;
    }
    values[period - 1] = sum / period;
    
    let ema = values[period - 1];
    for (let i = period; i < data.length; i++) {
        ema = (data[i].close * multiplier) + (ema * (1 - multiplier));
        values[i] = ema;
    }
    
    return values;
}</textarea>
            `;

            document.getElementById('indicators').appendChild(indicatorBox);

            const runBtn = indicatorBox.querySelector('.run-btn');
            const deleteBtn = indicatorBox.querySelector('.delete-btn');
            const colorInput = indicatorBox.querySelector('.indicator-color');
            const paneSelect = indicatorBox.querySelector('.indicator-pane');
            const nameInput = indicatorBox.querySelector('.indicator-name');
            const textarea = indicatorBox.querySelector('textarea');

            function updateIndicatorSettings() {
                const baseIndicator = activeIndicators.find(ind => ind.id === indicatorId + '_signals');
                if (baseIndicator) {
                    baseIndicator.color = colorInput.value;
                    baseIndicator.name = nameInput.value || 'Cloud Signals';
                    baseIndicator.pane = paneSelect.value;
                    drawCharts();
                }
            }

            colorInput.addEventListener('input', updateIndicatorSettings);
            paneSelect.addEventListener('change', updateIndicatorSettings);
            nameInput.addEventListener('input', updateIndicatorSettings);

            runBtn.addEventListener('click', function () {
                try {
                    const safeData = chartData.map(d => ({
                        close: d.close, open: d.open, high: d.high, low: d.low, time: d.time
                    }));

                    const func = new Function('data', `
                        try {
                            ${textarea.value}
                            const result = calculateIndicator(data);
                            if (!result || typeof result !== 'object') {
                                throw new Error('Must return object with signals, upper, lower');
                            }
                            return {
                                signals: ensureArrayLength(result.signals || [], data.length),
                                upper: ensureArrayLength(result.upper || [], data.length),
                                lower: ensureArrayLength(result.lower || [], data.length)
                            };
                        } catch (e) {
                            throw new Error('Cloud calculation error: ' + e.message);
                        }
                    `);

                    const result = func(safeData);

                    // Remove existing indicators
                    activeIndicators = activeIndicators.filter(ind => !ind.id.startsWith(indicatorId.toString()));

                    // Create signal indicator
                    const signalIndicator = {
                        id: indicatorId + '_signals',
                        name: nameInput.value || 'Cloud Signals',
                        values: result.signals,
                        color: colorInput.value,
                        pane: paneSelect.value,
                        type: 'cloud_signals'
                    };

                    // Create cloud boundaries for main chart
                    const upperIndicator = {
                        id: indicatorId + '_cloud_upper',
                        name: 'Cloud Upper',
                        values: result.upper,
                        color: '#22c55e',
                        pane: 'main',
                        type: 'cloud_upper'
                    };

                    const lowerIndicator = {
                        id: indicatorId + '_cloud_lower',
                        name: 'Cloud Lower',
                        values: result.lower,
                        color: '#ef4444',
                        pane: 'main',
                        type: 'cloud_lower'
                    };

                    activeIndicators.push(signalIndicator, upperIndicator, lowerIndicator);

                    runBtn.innerHTML = '<i class="fas fa-check"></i> Cloud Active!';
                    runBtn.style.background = '#16a34a';
                    setTimeout(() => {
                        runBtn.innerHTML = '<i class="fas fa-play"></i> Run Cloud';
                        runBtn.style.background = '';
                    }, 2000);

                    drawCharts();
                    console.log('Cloud indicator loaded successfully');

                } catch (error) {
                    console.error('Cloud indicator error:', error);
                    alert(`Cloud Error: ${error.message}\n\nEnsure you have enough data (>26 candles)`);
                }
            });

            deleteBtn.addEventListener('click', function () {
                activeIndicators = activeIndicators.filter(ind => !ind.id.startsWith(indicatorId.toString()));
                indicatorBox.remove();
                drawCharts();
            });

            // Auto-run
            setTimeout(() => {
                if (chartData.length > 26) runBtn.click();
            }, 500);
        }

        function setupChartInteraction() {
            mainCanvas.addEventListener('mousemove', function (e) {
                const rect = mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const padding = { left: 60, right: 60, top: 40, bottom: 40 };
                const chartWidth = mainCanvas.width - padding.left - padding.right;

                if (x >= padding.left && x <= mainCanvas.width - padding.right) {
                    const visibleData = chartData.slice(visibleStartIndex, visibleStartIndex + visibleDataPoints);
                    if (visibleData.length > 0) {
                        const localIndex = Math.floor(((x - padding.left) / chartWidth) * visibleData.length);
                        hoverIndex = Math.min(visibleStartIndex + localIndex, chartData.length - 1);

                        const tooltip = document.getElementById('tooltip');
                        if (hoverIndex >= 0 && hoverIndex < chartData.length) {
                            const bar = chartData[hoverIndex];
                            tooltip.innerHTML = `
                                Time: ${new Date(bar.time * 1000).toLocaleString()}<br>
                                O: ${bar.open.toFixed(5)} H: ${bar.high.toFixed(5)}<br>
                                L: ${bar.low.toFixed(5)} C: ${bar.close.toFixed(5)}
                            `;
                            tooltip.style.left = (e.clientX + 10) + 'px';
                            tooltip.style.top = (e.clientY - 10) + 'px';
                            tooltip.style.opacity = '1';
                        }
                    }
                } else {
                    hoverIndex = null;
                    document.getElementById('tooltip').style.opacity = '0';
                }

                drawCharts();
            });

            mainCanvas.addEventListener('mouseleave', () => {
                hoverIndex = null;
                document.getElementById('tooltip').style.opacity = '0';
                drawCharts();
            });
        }

        function updateUI() {
            updatePriceInfo();
            drawCharts();
        }

        // Initialize
        window.addEventListener('load', init);
    </script>
</body>

</html>